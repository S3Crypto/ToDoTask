{"ast":null,"code":"// -----------------\n// STATE - This defines the type of data maintained in the Redux store.\n// -----------------\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\n// They do not themselves have any side-effects; they just describe something that is going to happen.\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\n// declared type strings (and not any other arbitrary string).\n// ----------------\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\nexport var actionCreators = {\n  requestWeatherForecasts: function requestWeatherForecasts(startDateIndex) {\n    return function (dispatch, getState) {\n      // Only load data if it's something we don't already have (and are not already loading)\n      var appState = getState();\n\n      if (appState && appState.weatherForecasts && startDateIndex !== appState.weatherForecasts.startDateIndex) {\n        fetch(\"weatherforecast\").then(function (response) {\n          return response.json();\n        }).then(function (data) {\n          dispatch({\n            type: 'RECEIVE_WEATHER_FORECASTS',\n            startDateIndex: startDateIndex,\n            forecasts: data\n          });\n        });\n        dispatch({\n          type: 'REQUEST_WEATHER_FORECASTS',\n          startDateIndex: startDateIndex\n        });\n      }\n    };\n  }\n}; // ----------------\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\n\nvar unloadedState = {\n  forecasts: [],\n  isLoading: false\n};\nexport var reducer = function reducer(state, incomingAction) {\n  if (state === undefined) {\n    return unloadedState;\n  }\n\n  var action = incomingAction;\n\n  switch (action.type) {\n    case 'REQUEST_WEATHER_FORECASTS':\n      return {\n        startDateIndex: action.startDateIndex,\n        forecasts: state.forecasts,\n        isLoading: true\n      };\n\n    case 'RECEIVE_WEATHER_FORECASTS':\n      // Only accept the incoming data if it matches the most recent request. This ensures we correctly\n      // handle out-of-order responses.\n      if (action.startDateIndex === state.startDateIndex) {\n        return {\n          startDateIndex: action.startDateIndex,\n          forecasts: action.forecasts,\n          isLoading: false\n        };\n      }\n\n      break;\n  }\n\n  return state;\n};","map":{"version":3,"names":["actionCreators","requestWeatherForecasts","startDateIndex","dispatch","getState","appState","weatherForecasts","fetch","then","response","json","data","type","forecasts","unloadedState","isLoading","reducer","state","incomingAction","undefined","action"],"sources":["/Users/michaeldarlington/Projects/ToDoTask/ToDoTask/ClientApp/src/store/WeatherForecasts.ts"],"sourcesContent":["import { Action, Reducer } from 'redux';\nimport { AppThunkAction } from './';\n\n// -----------------\n// STATE - This defines the type of data maintained in the Redux store.\n\nexport interface WeatherForecastsState {\n    isLoading: boolean;\n    startDateIndex?: number;\n    forecasts: WeatherForecast[];\n}\n\nexport interface WeatherForecast {\n    date: string;\n    temperatureC: number;\n    temperatureF: number;\n    summary: string;\n}\n\n// -----------------\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\n// They do not themselves have any side-effects; they just describe something that is going to happen.\n\ninterface RequestWeatherForecastsAction {\n    type: 'REQUEST_WEATHER_FORECASTS';\n    startDateIndex: number;\n}\n\ninterface ReceiveWeatherForecastsAction {\n    type: 'RECEIVE_WEATHER_FORECASTS';\n    startDateIndex: number;\n    forecasts: WeatherForecast[];\n}\n\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\n// declared type strings (and not any other arbitrary string).\ntype KnownAction = RequestWeatherForecastsAction | ReceiveWeatherForecastsAction;\n\n// ----------------\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\n\nexport const actionCreators = {\n    requestWeatherForecasts: (startDateIndex: number): AppThunkAction<KnownAction> => (dispatch, getState) => {\n        // Only load data if it's something we don't already have (and are not already loading)\n        const appState = getState();\n        if (appState && appState.weatherForecasts && startDateIndex !== appState.weatherForecasts.startDateIndex) {\n            fetch(`weatherforecast`)\n                .then(response => response.json() as Promise<WeatherForecast[]>)\n                .then(data => {\n                    dispatch({ type: 'RECEIVE_WEATHER_FORECASTS', startDateIndex: startDateIndex, forecasts: data });\n                });\n\n            dispatch({ type: 'REQUEST_WEATHER_FORECASTS', startDateIndex: startDateIndex });\n        }\n    }\n};\n\n// ----------------\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\n\nconst unloadedState: WeatherForecastsState = { forecasts: [], isLoading: false };\n\nexport const reducer: Reducer<WeatherForecastsState> = (state: WeatherForecastsState | undefined, incomingAction: Action): WeatherForecastsState => {\n    if (state === undefined) {\n        return unloadedState;\n    }\n\n    const action = incomingAction as KnownAction;\n    switch (action.type) {\n        case 'REQUEST_WEATHER_FORECASTS':\n            return {\n                startDateIndex: action.startDateIndex,\n                forecasts: state.forecasts,\n                isLoading: true\n            };\n        case 'RECEIVE_WEATHER_FORECASTS':\n            // Only accept the incoming data if it matches the most recent request. This ensures we correctly\n            // handle out-of-order responses.\n            if (action.startDateIndex === state.startDateIndex) {\n                return {\n                    startDateIndex: action.startDateIndex,\n                    forecasts: action.forecasts,\n                    isLoading: false\n                };\n            }\n            break;\n    }\n\n    return state;\n};\n\n"],"mappings":"AAGA;AACA;AAeA;AACA;AACA;AAaA;AACA;AAGA;AACA;AACA;AAEA,OAAO,IAAMA,cAAc,GAAG;EAC1BC,uBAAuB,EAAE,iCAACC,cAAD;IAAA,OAAyD,UAACC,QAAD,EAAWC,QAAX,EAAwB;MACtG;MACA,IAAMC,QAAQ,GAAGD,QAAQ,EAAzB;;MACA,IAAIC,QAAQ,IAAIA,QAAQ,CAACC,gBAArB,IAAyCJ,cAAc,KAAKG,QAAQ,CAACC,gBAAT,CAA0BJ,cAA1F,EAA0G;QACtGK,KAAK,mBAAL,CACKC,IADL,CACU,UAAAC,QAAQ;UAAA,OAAIA,QAAQ,CAACC,IAAT,EAAJ;QAAA,CADlB,EAEKF,IAFL,CAEU,UAAAG,IAAI,EAAI;UACVR,QAAQ,CAAC;YAAES,IAAI,EAAE,2BAAR;YAAqCV,cAAc,EAAEA,cAArD;YAAqEW,SAAS,EAAEF;UAAhF,CAAD,CAAR;QACH,CAJL;QAMAR,QAAQ,CAAC;UAAES,IAAI,EAAE,2BAAR;UAAqCV,cAAc,EAAEA;QAArD,CAAD,CAAR;MACH;IACJ,CAZwB;EAAA;AADC,CAAvB,C,CAgBP;AACA;;AAEA,IAAMY,aAAoC,GAAG;EAAED,SAAS,EAAE,EAAb;EAAiBE,SAAS,EAAE;AAA5B,CAA7C;AAEA,OAAO,IAAMC,OAAuC,GAAG,SAA1CA,OAA0C,CAACC,KAAD,EAA2CC,cAA3C,EAA6F;EAChJ,IAAID,KAAK,KAAKE,SAAd,EAAyB;IACrB,OAAOL,aAAP;EACH;;EAED,IAAMM,MAAM,GAAGF,cAAf;;EACA,QAAQE,MAAM,CAACR,IAAf;IACI,KAAK,2BAAL;MACI,OAAO;QACHV,cAAc,EAAEkB,MAAM,CAAClB,cADpB;QAEHW,SAAS,EAAEI,KAAK,CAACJ,SAFd;QAGHE,SAAS,EAAE;MAHR,CAAP;;IAKJ,KAAK,2BAAL;MACI;MACA;MACA,IAAIK,MAAM,CAAClB,cAAP,KAA0Be,KAAK,CAACf,cAApC,EAAoD;QAChD,OAAO;UACHA,cAAc,EAAEkB,MAAM,CAAClB,cADpB;UAEHW,SAAS,EAAEO,MAAM,CAACP,SAFf;UAGHE,SAAS,EAAE;QAHR,CAAP;MAKH;;MACD;EAjBR;;EAoBA,OAAOE,KAAP;AACH,CA3BM"},"metadata":{},"sourceType":"module"}